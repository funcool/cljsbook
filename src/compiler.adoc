=== Getting Started with the ClojureScript compiler

At this point, you are surely very bored with the constant theoretical explanations about the language
itself and will want to write and execute some code. The goal of this section is to provide a little practical
introduction to the _ClojureScript_ compiler.

The _ClojureScript_ compiler takes the source code that has been split over numerous directories and namespaces and
compiles it down to JavaScript. Today, JavaScript has great number of different environments
where it can be executed - each with its own pecularities.

This chapter intends to explain how to use _ClojureScript_ without any additional tooling. This
will help you understand how the compiler works and how you can use it when other tooling is not
available (such as leiningen+cljsbuld or boot).


==== Execution environments

What is an execution environment? An execution environment is an engine where JavaScript can be
executed. For example, the most popular execution environment is a browser (Chrome, Firefox, ...)
followed by the second most popular - nodejs/iojs.

There are others, such as Rhino (jdk6+), Nashorn (jdk8), QtQuick (QT),... but none of them have
significant differences from the first two. So, _ClojureScript_ at the moment may compile
code to run in the browser or in nodejs/iojs like environments out of the box.

==== Download the compiler

The _ClojureScript_ compiler is implemented in java, and to use it, you should have jdk8 installed.
_ClojureScript_ itself only requires jdk7, but the standalone compiler that we going to use in this
chapter requires jdk8 which can be found at http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html

You can download it using `wget`:

[source, bash]
----
wget https://github.com/clojure/clojurescript/releases/download/r3211/cljs.jar
----

The _ClojureScript_ compiler is packaged in a standalone executable jar file, so this is the only
file and JDK8 that you need to compile the _ClojureScript_ source code to JavaScript.


==== Compile for nodejs/iojs

Let start with a practical example compiling code that will target *nodejs*/*iojs*. For
this example you should have nodejs or iojs (recommended) installed.

There are different ways to install iojs, but the recommended way is using nvm (node version
manager). You can read the instructions to install and use nvm at: https://github.com/creationix/nvm[home page].

You can test if *iojs* is installed in your system with this command:

[source, shell]
----
$ iojs --version
v1.7.1
----

===== Create the example application

For the first step of our practical example, we will create our application directory structure
and populate it with example code.

So start creating the directory tree structure for our "hello world" application:

[source, bash]
----
mkdir -p src/myapp
touch src/myapp/core.cljs
----

Second, write the example code into the previously created `src/myapp/core.cljs` file:

[source, clojure]
----
(ns myapp.core
  (:require [cljs.nodejs :as nodejs]))

(nodejs/enable-util-print!)

(defn -main [& args]
  (println "Hello world!"))

(set! *main-cli-fn* -main)
----

NOTE: It is very important that the declared namespace in the file exactly matches the directory
structure. This is the way _ClojureScript_ structures its source code.


===== Compile the example application

In order to compile that source code, we need a simple build script that instructs the
_ClojureScript_ compiler with the source directory and the output file. _ClojureScript_ has a
lot of other options but at this moment we can ignore that.

Lets create the _build.clj_ file with the following content:

[source, clojure]
----
(require 'cljs.closure)

(cljs.closure/build "src"
 {:output-to "main.js"
  :main 'myapp.core
  :target :nodejs})
----

This is a brief explanation of the compiler options used in this example:

* The `:output-to` parameter indicates to the compiler the destination of the compiled code, in this
  case to the "main.js" file.
* The `:main` property indicates to the compiler the namespace that will act as the entry point of
  your application when it's executed.
* The `:target` property indicates the platform where you want execute the compiled code. In this case
  we are going to use *iojs* (formerly nodejs). If you omit this parameter, the source will be
  compiled to run in the browser environment.

To run the compilation, just execute the following command:

[source, bash]
----
java -cp cljs.jar:src clojure.main build.clj
----

And when it finishes, execute the compiled file using *iojs*:

[source, shell]
----
$ iojs main.js
Hello world!
----


==== Compile for the Browser

In this section we are going to create a similar "hello world" example application from the
previous section to run in the browser environent. The minimal requirement for it
is just a browser that can execute JavaScript.

The process is almost the same, the directory structure is the same. The only things that
changes is the entry point of the application and the build script.

Start writing new content to the `src/myapp/core.cljs` file:

[source, clojure]
----
(ns myapp.core)

(enable-console-print!)

(println "Hello world!")
----

In the browser environment we do not need a specific entry point for the application,
so the entry point is the entire namespace.


===== Compile the example application

In order to compile the source code to run properly in a browser, overwrite
the _build.clj_ file with the following content:

[source, clojure]
----
(require 'cljs.closure)

(cljs.closure/build "src"
 {:output-to "main.js"
  :output-dir "out/"
  :source-map "main.js.map"
  :main 'myapp.core
  :optimizations :none})
----

This is a brief explanation of the compiler options we're using:

* The `:output-to` parameter indicates to the compiler the destination of the compiled code, in this
  case to the "main.js" file.
* The `:main` property indicates to the compiler the namespace that will act as the entry point of
  your application when it's executed.
* `:source-map` indicates the destination of the source map. (The source map connects the ClojureScript source
  to the generated JavaScript so that error messages can point you back to the original source.)
* `:output-dir` indicates the destination directory for all files sources used in a compilation. It is
  just for making source maps work properly with the rest of code, not only your source.
* `:optimizations` indicates the compilation optimization. There are different values for this option,
  but that will be covered in following sections in more detail.

To run the compilation, just execute the following command:

[source, bash]
----
java -cp cljs.jar:src clojure.main build.clj
----

This process can take some time, so do not worry, wait a little bit. The JVM bootstrap with Clojure
compiler is slightly slow. In the following sections we will explain how to start a watch process to avoid
constantly starting and stopping this slow process.

While waiting for the compilation, let's create a dummy HTML file to make it easy to execute our example
app in the browser. Create the _index.html_ file with the following content; it goes in the main _myapp_
directory.

[source, html]
----
<!DOCTYPE html>
<html>
  <header>
    <meta charset="utf-8" />
    <title>Hello World from ClojureScript</title>
  </header>
  <body>
    <script src="main.js"></script>
  </body>
</html>
----

Now, when the compilation finishes and you have the basic HTML file you can just open it with your favorite
browser and take a look in the development tools console. There should appear the "hello world" message.

////
Note: I also get this message "ReferenceError: require is not defined"
TODO: revise the examples code.
////


==== Watch process

Surely, you have already experienced the slow startup of the _ClojureScript_ compiler. To solve this,
the _ClojureScript_ standalone compiler also comes with tools to start a process that watches the changes
in some directory and perform an incremental compilation.

Start creating another build script, but in this case name it _watch.clj_:

[source, clojure]
----
(require 'cljs.closure)

(cljs.closure/watch "src"
 {:output-to "main.js"
  :output-dir "out/"
  :source-map "main.js.map"
  :main 'myapp.core
  :optimizations :none})
----

Now, execute that script like any other that you have executed in previous sections:

[source, bash]
----
$ java -cp cljs.jar:src clojure.main watch.clj
Building ...
Reading analysis cache for jar:file:/home/niwi/cljsbook/playground/cljs.jar!/cljs/core.cljs
Compiling out/cljs/core.cljs
Using cached cljs.core out/cljs/core.cljs
... done. Elapsed 0.8354759 seconds
Watching paths: /home/niwi/cljsbook/playground/src

Change detected, recompiling ...
Compiling src/myapp/core.cljs
Compiling out/cljs/core.cljs
Using cached cljs.core out/cljs/core.cljs
... done. Elapsed 0.191963443 seconds
----

You can observe that in the second compilation, the time is drastically reduced. Another advantage
of this method is that it is a gives a little bit more output.


==== Optimization levels

The _ClojureScript_ compiler has different level of optimizations. Behind the scenes, those compilation
levels are coming from Google Closure Compiler.

A very simplified overview of the compilation process is:

1. The reader reads the code and makes some analysis. This process can raise some warnings
   during its phase.
2. Then, the _ClojureScript_ compiler emits JavaScript code. The result of that is one JavaScript
   file for each cljs file.
3. The generated files passes through the Closure Compiler that depending on the optimization level,
   and other options (sourcemaps, output dir output to, ...) generates the final output.

The final output depends strictly on the optimization level.


===== none

Implies that closure compiler just writes the files as is, without any additional
optimization applied to the source code. This optimization level is mandatory if you are targeting
*nodejs* or *iojs* and is appropiate in development mode when your code targets the browser.


===== whitespace

This optimization level consists of concatenating the compiled files in an appropriate order, removing
line breaks and other whitespace and generating the output as one large file.

It also has some compilation speed penalty, resulting in slower compilations. In any case, it is not
terribly slow and is completely usable in small/medium applications.


===== simple

The simple compilation level implies (includes) all transformations from whitespace optimization and
additionally performs optimizations within expressions and functions, including renaming local variables
and function parameters to shorter names.

Compilation with the `:simple` optimization always preserves the functionality of syntactically valid
JavaScript, so it does not interfere with the interaction between the compiled _ClojureScript_ and
other JavaScript.

===== advanced

TBD


=== Working with the REPL

Although you can create a source file and compile it every time you want to try something out in ClojureScript, it’s
easier to use the REPL. REPL stands for:

* Read - get input from the keyboard
* Evaluate the input
* Print the result
* Loop back for more input

In other words, the REPL lets you try out ClojureScript concepts and get immediate feedback.

Create a file named `brepl.clj` with the following content, adapted from the
[ClojureScript Quick Start Wiki Page](https://github.com/clojure/clojurescript/wiki/Quick-Start).

````
(require 'cljs.repl)
(require 'cljs.closure)
(require 'cljs.repl.browser)

(cljs.closure/build "src"
  {:main 'myapp.core
   :output-to "main.js"
   :verbose true})

(cljs.repl/repl (cljs.repl.browser/repl-env)
  :watch "src"
  :output-dir "out/")
````

This script builds the source, just as we did earlier, and then starts the REPL.
It then runs the REPL. watching the source directory for any changes. The REPL starts
a mini web server to display your web page. You must change your ClojureScript code
to connect your script to the REPL.  Change the source code in _src/myapp/core.cljs_ to read:

````
(ns myapp.core
 (:require [clojure.browser.repl :as repl]))

(defonce conn
  (repl/connect "http://localhost:9000/repl"))

(enable-console-print!)

(println "Hello, world!")
````

The `:require` has changed to use code from the `clojure.browser.repl` library, and then defines a
connection to the REPL, which will be running on port 9000 of ClojureScript's mini-server.

There’s one more step to take. On Linux and Mac OSX, the REPL doesn’t automatically let you use the arrow
keys to move back and forth within a line or up and down to see previously entered input. Instead, you
need to use the `rlwrap` program to give you that capability. (Its name comes from the fact that it
wraps the “readline” utility around other programs.)

Well, that was a lot of setup! But trust us, it’s all worth it when you see it in action.
Here it is, with a ClojureScript expression typed in as an example:

[source, bash]
````
$ rlwrap java -cp cljs.jar:src clojure.main brepl.clj
Compiling client js ...
Waiting for browser to connect ...
Watch compilation log available at: out/watch.log
To quit, type: :cljs/quit
cljs.user=> (+ 14 28)
42
cljs.user=> 
````

Since you are watching the source code, if you make changes, your program will recompile, and the compiler output
will go to the _watch.log_ file in the _out_ directory. If you are on Mac OSX or Linux, you can open up a new
terminal window and use this command to see the contents of the file continuously updated:

````
tail -f out/watch.log
````

=== Build and Dependency management tools

==== Getting started with Leiningen.

TBD

==== Getting started with boot.

TBD


=== The Closure Library

TBD


=== Browser based development

TBD

//^ A little guide and notes about implications of developing for web
//^ environments (optimizations, third party libraries, modularization, ...)

==== Using third party JavaScript libraries

TBD


====  Modularizing your code

//^ Mainly related to google closure modules and slightly related to web based development
//^ Maybe this is not the chapter for this section.

TBD



=== Developing a library

//^ A little guide and implications of developing a library for clojurescript.

TBD


=== Unit testing

TBD
